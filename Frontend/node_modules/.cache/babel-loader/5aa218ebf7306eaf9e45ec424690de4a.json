{"ast":null,"code":"import _toConsumableArray from \"/Users/moe/Documents/reactSimple/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { ActionTypes } from './useListbox.types';\nvar pageSize = 5;\nfunction findValidOptionToHighlight(index, lookupDirection, options, focusDisabled, isOptionDisabled, wrapAround) {\n  if (options.length === 0 || options.every(function (o, i) {\n    return isOptionDisabled(o, i);\n  })) {\n    return -1;\n  }\n  var nextFocus = index;\n  for (;;) {\n    // No valid options found\n    if (!wrapAround && lookupDirection === 'next' && nextFocus === options.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {\n      return -1;\n    }\n    var nextFocusDisabled = focusDisabled ? false : isOptionDisabled(options[nextFocus], nextFocus);\n    if (nextFocusDisabled) {\n      nextFocus += lookupDirection === 'next' ? 1 : -1;\n      if (wrapAround) {\n        nextFocus = (nextFocus + options.length) % options.length;\n      }\n    } else {\n      return nextFocus;\n    }\n  }\n}\nfunction getNewHighlightedOption(options, previouslyHighlightedOption, diff, highlightDisabledOptions, isOptionDisabled, disableListWrap, optionComparer) {\n  var _options$nextIndex;\n  var maxIndex = options.length - 1;\n  var defaultHighlightedIndex = -1;\n  var previouslyHighlightedIndex = previouslyHighlightedOption == null ? -1 : options.findIndex(function (option) {\n    return optionComparer(option, previouslyHighlightedOption);\n  });\n  var nextIndexCandidate;\n  var lookupDirection;\n  var wrapAround;\n  switch (diff) {\n    case 'reset':\n      if (defaultHighlightedIndex === -1) {\n        return null;\n      }\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'start':\n      nextIndexCandidate = 0;\n      lookupDirection = 'next';\n      wrapAround = false;\n      break;\n    case 'end':\n      nextIndexCandidate = maxIndex;\n      lookupDirection = 'previous';\n      wrapAround = false;\n      break;\n    default:\n      {\n        var newIndex = previouslyHighlightedIndex + diff;\n        wrapAround = !disableListWrap;\n        if (newIndex < 0) {\n          if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(diff) > 1) {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          } else {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          }\n        } else if (newIndex > maxIndex) {\n          if (!wrapAround || Math.abs(diff) > 1) {\n            nextIndexCandidate = maxIndex;\n            lookupDirection = 'previous';\n          } else {\n            nextIndexCandidate = 0;\n            lookupDirection = 'next';\n          }\n        } else {\n          nextIndexCandidate = newIndex;\n          lookupDirection = diff >= 0 ? 'next' : 'previous';\n        }\n      }\n  }\n  var nextIndex = findValidOptionToHighlight(nextIndexCandidate, lookupDirection, options, highlightDisabledOptions, isOptionDisabled, wrapAround);\n  return (_options$nextIndex = options[nextIndex]) != null ? _options$nextIndex : null;\n}\nfunction moveHighlight(previouslyHighlightedOption, diff, props) {\n  var options = props.options,\n    isOptionDisabled = props.isOptionDisabled,\n    disableListWrap = props.disableListWrap,\n    disabledItemsFocusable = props.disabledItemsFocusable,\n    optionComparer = props.optionComparer;\n  return getNewHighlightedOption(options, previouslyHighlightedOption, diff, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : function () {\n    return false;\n  }, disableListWrap != null ? disableListWrap : false, optionComparer != null ? optionComparer : function (o1, o2) {\n    return o1 === o2;\n  });\n}\nfunction toggleSelection(option, selectedOptions, selectionLimit, optionComparer) {\n  if (selectionLimit === 0) {\n    return [];\n  }\n\n  // Selection limit = 1 is a special case - we don't want to allow deselecting the option.\n  if (selectionLimit === 1) {\n    if (optionComparer(selectedOptions[0], option)) {\n      return selectedOptions;\n    }\n    return [option];\n  }\n\n  // The toggled option is selected; remove it from the selection.\n  if (selectedOptions.some(function (so) {\n    return optionComparer(so, option);\n  })) {\n    return selectedOptions.filter(function (so) {\n      return !optionComparer(so, option);\n    });\n  }\n\n  // The toggled option is not selected and the selected array is shorter than the limit - add to the selection.\n  if (selectionLimit === null || selectedOptions.length < selectionLimit) {\n    return [].concat(_toConsumableArray(selectedOptions), [option]);\n  }\n\n  // Truncate the selection to the limit (discard items with lower indexes).\n  var newSelection = selectedOptions.slice(selectedOptions.length - selectionLimit + 1);\n  newSelection.push(option);\n  return newSelection;\n}\nfunction handleOptionSelection(option, state, props) {\n  var _props$optionComparer = props.optionComparer,\n    optionComparer = _props$optionComparer === void 0 ? function (o, v) {\n      return o === v;\n    } : _props$optionComparer,\n    _props$isOptionDisabl = props.isOptionDisabled,\n    isOptionDisabled = _props$isOptionDisabl === void 0 ? function () {\n      return false;\n    } : _props$isOptionDisabl,\n    selectionLimit = props.selectionLimit;\n  var selectedValues = state.selectedValues;\n  var optionIndex = props.options.findIndex(function (o) {\n    return props.optionComparer(option, o);\n  });\n  if (isOptionDisabled(option, optionIndex)) {\n    return state;\n  }\n\n  // if the option is already selected, remove it from the selection, otherwise add it\n  var newSelectedValues = toggleSelection(option, selectedValues, selectionLimit, optionComparer);\n  return {\n    selectedValues: newSelectedValues,\n    highlightedValue: option\n  };\n}\nfunction handleKeyDown(event, state, parameters) {\n  var previouslySelectedValue = state.highlightedValue;\n  switch (event.key) {\n    case 'Home':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'start', parameters)\n      });\n    case 'End':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 'end', parameters)\n      });\n    case 'PageUp':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -pageSize, parameters)\n      });\n    case 'PageDown':\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, pageSize, parameters)\n      });\n    case 'ArrowUp':\n      // TODO: extend current selection with Shift modifier\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, -1, parameters)\n      });\n    case 'ArrowDown':\n      // TODO: extend current selection with Shift modifier\n      return _extends({}, state, {\n        highlightedValue: moveHighlight(previouslySelectedValue, 1, parameters)\n      });\n    case 'Enter':\n    case ' ':\n      if (state.highlightedValue === null) {\n        return state;\n      }\n      return handleOptionSelection(state.highlightedValue, state, parameters);\n    default:\n      break;\n  }\n  return state;\n}\nfunction handleBlur(state) {\n  return _extends({}, state, {\n    highlightedValue: null\n  });\n}\nvar textCriteriaMatches = function textCriteriaMatches(nextFocus, searchString, stringifyOption) {\n  var _stringifyOption;\n  var text = (_stringifyOption = stringifyOption(nextFocus)) == null ? void 0 : _stringifyOption.trim().toLowerCase();\n  if (!text || text.length === 0) {\n    // Make option not navigable if stringification fails or results in empty string.\n    return false;\n  }\n  return text.indexOf(searchString) === 0;\n};\nfunction handleTextNavigation(state, searchString, props) {\n  var options = props.options,\n    isOptionDisabled = props.isOptionDisabled,\n    disableListWrap = props.disableListWrap,\n    disabledItemsFocusable = props.disabledItemsFocusable,\n    optionComparer = props.optionComparer,\n    optionStringifier = props.optionStringifier;\n  var startWithCurrentOption = searchString.length > 1;\n  var nextOption = startWithCurrentOption ? state.highlightedValue : getNewHighlightedOption(options, state.highlightedValue, 1, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : function () {\n    return false;\n  }, disableListWrap != null ? disableListWrap : false, optionComparer);\n\n  // use `for` instead of `while` prevent infinite loop\n  for (var index = 0; index < options.length; index += 1) {\n    // Return un-mutated state if looped back to the currently highlighted value\n    if (!nextOption || !startWithCurrentOption && state.highlightedValue === nextOption) {\n      return state;\n    }\n    if (textCriteriaMatches(nextOption, searchString, optionStringifier) && (!isOptionDisabled(nextOption, options.indexOf(nextOption)) || disabledItemsFocusable)) {\n      // The nextOption is the element to be highlighted\n      return _extends({}, state, {\n        highlightedValue: nextOption\n      });\n    }\n    // Move to the next element.\n    nextOption = getNewHighlightedOption(options, nextOption, 1, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : function () {\n      return false;\n    }, disableListWrap != null ? disableListWrap : false, optionComparer);\n  }\n\n  // No option match text search criteria\n  return state;\n}\nfunction handleOptionsChange(options, state, props) {\n  var _options$find, _state$selectedValues;\n  var optionComparer = props.optionComparer;\n  var newHighlightedOption = state.highlightedValue == null ? null : (_options$find = options.find(function (option) {\n    return optionComparer(option, state.highlightedValue);\n  })) != null ? _options$find : null;\n\n  // exclude selected values that are no longer in the options\n  var selectedValues = (_state$selectedValues = state.selectedValues) != null ? _state$selectedValues : [];\n  var newSelectedValues = selectedValues.filter(function (selectedValue) {\n    return options.some(function (option) {\n      return optionComparer(option, selectedValue);\n    });\n  });\n  return {\n    highlightedValue: newHighlightedOption,\n    selectedValues: newSelectedValues\n  };\n}\nexport default function defaultListboxReducer(state, action) {\n  var type = action.type;\n  switch (type) {\n    case ActionTypes.keyDown:\n      return handleKeyDown(action.event, state, action.props);\n    case ActionTypes.optionClick:\n      return handleOptionSelection(action.option, state, action.props);\n    case ActionTypes.blur:\n      return handleBlur(state);\n    case ActionTypes.setValue:\n      return _extends({}, state, {\n        selectedValues: action.value\n      });\n    case ActionTypes.setHighlight:\n      return _extends({}, state, {\n        highlightedValue: action.highlight\n      });\n    case ActionTypes.textNavigation:\n      return handleTextNavigation(state, action.searchString, action.props);\n    case ActionTypes.optionsChange:\n      return handleOptionsChange(action.options, state, action.props);\n    default:\n      return state;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}