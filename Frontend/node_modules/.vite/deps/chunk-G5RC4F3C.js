import {
  require_react_dom
} from "./chunk-RE32X576.js";
import {
  require_hoist_non_react_statics_cjs,
  require_prop_types
} from "./chunk-ASPVDMEZ.js";
import {
  require_react
} from "./chunk-XWQ7Z5YS.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/react-hot-loader/dist/react-hot-loader.production.min.js
var require_react_hot_loader_production_min = __commonJS({
  "node_modules/react-hot-loader/dist/react-hot-loader.production.min.js"(exports) {
    "use strict";
    function _interopDefault(e) {
      return e && "object" == typeof e && "default" in e ? e.default : e;
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = _interopDefault(require_react());
    function AppContainer(e) {
      return AppContainer.warnAboutHMRDisabled && (AppContainer.warnAboutHMRDisabled = true, console.error("React-Hot-Loader: misconfiguration detected, using production version in non-production environment."), console.error("React-Hot-Loader: Hot Module Replacement is not enabled.")), React.Children.only(e.children);
    }
    AppContainer.warnAboutHMRDisabled = false;
    var hot = function e() {
      return e.shouldWrapWithAppContainer ? function(e2) {
        return function(n) {
          return React.createElement(AppContainer, null, React.createElement(e2, n));
        };
      } : function(e2) {
        return e2;
      };
    };
    hot.shouldWrapWithAppContainer = false;
    var areComponentsEqual = function(e, n) {
      return e === n;
    };
    var setConfig = function() {
    };
    var cold = function(e) {
      return e;
    };
    var configureComponent = function() {
    };
    exports.AppContainer = AppContainer, exports.hot = hot, exports.areComponentsEqual = areComponentsEqual, exports.setConfig = setConfig, exports.cold = cold, exports.configureComponent = configureComponent;
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/fast-levenshtein/levenshtein.js
var require_levenshtein = __commonJS({
  "node_modules/fast-levenshtein/levenshtein.js"(exports, module) {
    (function() {
      "use strict";
      var collator;
      try {
        collator = typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined" ? Intl.Collator("generic", { sensitivity: "base" }) : null;
      } catch (err) {
        console.log("Collator could not be initialized and wouldn't be used");
      }
      var prevRow = [], str2Char = [];
      var Levenshtein = {
        get: function(str1, str2, options) {
          var useCollator = options && collator && options.useCollator;
          var str1Len = str1.length, str2Len = str2.length;
          if (str1Len === 0)
            return str2Len;
          if (str2Len === 0)
            return str1Len;
          var curCol, nextCol, i, j, tmp;
          for (i = 0; i < str2Len; ++i) {
            prevRow[i] = i;
            str2Char[i] = str2.charCodeAt(i);
          }
          prevRow[str2Len] = str2Len;
          var strCmp;
          if (useCollator) {
            for (i = 0; i < str1Len; ++i) {
              nextCol = i + 1;
              for (j = 0; j < str2Len; ++j) {
                curCol = nextCol;
                strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));
                nextCol = prevRow[j] + (strCmp ? 0 : 1);
                tmp = curCol + 1;
                if (nextCol > tmp) {
                  nextCol = tmp;
                }
                tmp = prevRow[j + 1] + 1;
                if (nextCol > tmp) {
                  nextCol = tmp;
                }
                prevRow[j] = curCol;
              }
              prevRow[j] = nextCol;
            }
          } else {
            for (i = 0; i < str1Len; ++i) {
              nextCol = i + 1;
              for (j = 0; j < str2Len; ++j) {
                curCol = nextCol;
                strCmp = str1.charCodeAt(i) === str2Char[j];
                nextCol = prevRow[j] + (strCmp ? 0 : 1);
                tmp = curCol + 1;
                if (nextCol > tmp) {
                  nextCol = tmp;
                }
                tmp = prevRow[j + 1] + 1;
                if (nextCol > tmp) {
                  nextCol = tmp;
                }
                prevRow[j] = curCol;
              }
              prevRow[j] = nextCol;
            }
          }
          return nextCol;
        }
      };
      if (typeof define !== "undefined" && define !== null && define.amd) {
        define(function() {
          return Levenshtein;
        });
      } else if (typeof module !== "undefined" && module !== null && typeof exports !== "undefined" && module.exports === exports) {
        module.exports = Levenshtein;
      } else if (typeof self !== "undefined" && typeof self.postMessage === "function" && typeof self.importScripts === "function") {
        self.Levenshtein = Levenshtein;
      } else if (typeof window !== "undefined" && window !== null) {
        window.Levenshtein = Levenshtein;
      }
    })();
  }
});

// node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js
var react_lifecycles_compat_es_exports = {};
__export(react_lifecycles_compat_es_exports, {
  polyfill: () => polyfill
});
function componentWillMount() {
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== void 0) {
    this.setState(state);
  }
}
function componentWillReceiveProps(nextProps) {
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== void 0 ? state : null;
  }
  this.setState(updater.bind(this));
}
function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}
function polyfill(Component) {
  var prototype = Component.prototype;
  if (!prototype || !prototype.isReactComponent) {
    throw new Error("Can only polyfill class components");
  }
  if (typeof Component.getDerivedStateFromProps !== "function" && typeof prototype.getSnapshotBeforeUpdate !== "function") {
    return Component;
  }
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === "function") {
    foundWillMountName = "componentWillMount";
  } else if (typeof prototype.UNSAFE_componentWillMount === "function") {
    foundWillMountName = "UNSAFE_componentWillMount";
  }
  if (typeof prototype.componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "componentWillReceiveProps";
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
  }
  if (typeof prototype.componentWillUpdate === "function") {
    foundWillUpdateName = "componentWillUpdate";
  } else if (typeof prototype.UNSAFE_componentWillUpdate === "function") {
    foundWillUpdateName = "UNSAFE_componentWillUpdate";
  }
  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
    var componentName = Component.displayName || Component.name;
    var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
    throw Error(
      "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (foundWillMountName !== null ? "\n  " + foundWillMountName : "") + (foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "") + (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks"
    );
  }
  if (typeof Component.getDerivedStateFromProps === "function") {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }
  if (typeof prototype.getSnapshotBeforeUpdate === "function") {
    if (typeof prototype.componentDidUpdate !== "function") {
      throw new Error(
        "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
      );
    }
    prototype.componentWillUpdate = componentWillUpdate;
    var componentDidUpdate = prototype.componentDidUpdate;
    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }
  return Component;
}
var init_react_lifecycles_compat_es = __esm({
  "node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js"() {
    componentWillMount.__suppressDeprecationWarning = true;
    componentWillReceiveProps.__suppressDeprecationWarning = true;
    componentWillUpdate.__suppressDeprecationWarning = true;
  }
});

// node_modules/react-hot-loader/dist/react-hot-loader.development.js
var require_react_hot_loader_development = __commonJS({
  "node_modules/react-hot-loader/dist/react-hot-loader.development.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var React = require_react();
    var React__default = _interopDefault(React);
    var shallowEqual = _interopDefault(require_shallowequal());
    var levenshtein = _interopDefault(require_levenshtein());
    var ReactDOM = _interopDefault(require_react_dom());
    var PropTypes = _interopDefault(require_prop_types());
    var defaultPolyfill = (init_react_lifecycles_compat_es(), __toCommonJS(react_lifecycles_compat_es_exports));
    var defaultPolyfill__default = _interopDefault(defaultPolyfill);
    var hoistNonReactStatic = _interopDefault(require_hoist_non_react_statics_cjs());
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var inherits = function(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };
    var possibleConstructorReturn = function(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    };
    var isCompositeComponent = function isCompositeComponent2(type) {
      return typeof type === "function";
    };
    var isReloadableComponent = function isReloadableComponent2(type) {
      return typeof type === "function" || (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object";
    };
    var getComponentDisplayName = function getComponentDisplayName2(type) {
      var displayName = type.displayName || type.name;
      return displayName && displayName !== "ReactComponent" ? displayName : "Component";
    };
    var reactLifeCycleMountMethods = ["componentWillMount", "componentDidMount"];
    function isReactClass(Component) {
      return !!(Component.prototype && (React__default.Component.prototype.isPrototypeOf(Component.prototype) || Component.prototype.isReactComponent || Component.prototype.componentWillMount || Component.prototype.componentWillUnmount || Component.prototype.componentDidMount || Component.prototype.componentDidUnmount || Component.prototype.render));
    }
    function isReactClassInstance(Component) {
      return Component && isReactClass({ prototype: Object.getPrototypeOf(Component) });
    }
    var getInternalInstance = function getInternalInstance2(instance) {
      return instance._reactInternalFiber || instance._reactInternalInstance || null;
    };
    var updateInstance = function updateInstance2(instance) {
      var updater = instance.updater, forceUpdate = instance.forceUpdate;
      if (typeof forceUpdate === "function") {
        instance.forceUpdate();
      } else if (updater && typeof updater.enqueueForceUpdate === "function") {
        updater.enqueueForceUpdate(instance);
      }
    };
    var isFragmentNode = function isFragmentNode2(_ref) {
      var type = _ref.type;
      return React__default.Fragment && type === React__default.Fragment;
    };
    var ContextType = React__default.createContext ? React__default.createContext() : null;
    var ConsumerType = ContextType && ContextType.Consumer.$$typeof;
    var ProviderType = ContextType && ContextType.Provider.$$typeof;
    var MemoType = React__default.memo && React__default.memo(function() {
      return null;
    }).$$typeof;
    var LazyType = React__default.lazy && React__default.lazy(function() {
      return null;
    }).$$typeof;
    var ForwardType = React__default.forwardRef && React__default.forwardRef(function() {
      return null;
    }).$$typeof;
    var CONTEXT_CURRENT_VALUE = "_currentValue";
    var isContextConsumer = function isContextConsumer2(_ref2) {
      var type = _ref2.type;
      return type && (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object" && "$$typeof" in type && type.$$typeof === ConsumerType && ConsumerType;
    };
    var isContextProvider = function isContextProvider2(_ref3) {
      var type = _ref3.type;
      return type && (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object" && "$$typeof" in type && type.$$typeof === ProviderType && ProviderType;
    };
    var isMemoType = function isMemoType2(_ref4) {
      var type = _ref4.type;
      return type && (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object" && "$$typeof" in type && type.$$typeof === MemoType && MemoType;
    };
    var isLazyType = function isLazyType2(_ref5) {
      var type = _ref5.type;
      return type && (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object" && "$$typeof" in type && type.$$typeof === LazyType && LazyType;
    };
    var isForwardType = function isForwardType2(_ref6) {
      var type = _ref6.type;
      return type && (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object" && "$$typeof" in type && type.$$typeof === ForwardType && ForwardType;
    };
    var isContextType = function isContextType2(type) {
      return isContextConsumer(type) || isContextProvider(type);
    };
    var getElementType = function getElementType2(type) {
      var element = { type };
      if (isContextConsumer(element)) {
        return "Consumer";
      }
      if (isContextProvider(element)) {
        return "Provider";
      }
      if (isLazyType(element)) {
        return "Lazy";
      }
      if (isMemoType(element)) {
        return "Memo";
      }
      if (isForwardType(element)) {
        return "Forward";
      }
      if (isReactClass(type)) {
        return "Class";
      }
      if (typeof element === "function") {
        return "FC";
      }
      return "unknown";
    };
    var getContextProvider = function getContextProvider2(type) {
      return type && type._context;
    };
    var configuration = {
      logLevel: "error",
      pureSFC: true,
      pureRender: true,
      allowSFC: true,
      reloadHooks: true,
      reloadLifeCycleHooks: false,
      reloadHooksOnBodyChange: true,
      disableHotRenderer: false,
      integratedComparator: false,
      integratedResolver: false,
      disableHotRendererWhenInjected: true,
      showReactDomPatchNotification: true,
      onComponentRegister: false,
      onComponentCreate: false,
      ignoreSFC: false,
      ignoreSFCWhenInjected: true,
      ignoreComponents: false,
      errorReporter: void 0,
      ErrorOverlay: void 0,
      trackTailUpdates: true,
      wrapLazy: true,
      IS_REACT_MERGE_ENABLED: false
    };
    var internalConfiguration = {
      disableProxyCreation: false
    };
    var setConfiguration = function setConfiguration2(config) {
      for (var i in config) {
        if (config.hasOwnProperty(i)) {
          configuration[i] = config[i];
        }
      }
    };
    var logger = {
      debug: function debug() {
        if (["debug"].indexOf(configuration.logLevel) !== -1) {
          var _console;
          (_console = console).debug.apply(_console, arguments);
        }
      },
      log: function log() {
        if (["debug", "log"].indexOf(configuration.logLevel) !== -1) {
          var _console2;
          (_console2 = console).log.apply(_console2, arguments);
        }
      },
      warn: function warn() {
        if (["debug", "log", "warn"].indexOf(configuration.logLevel) !== -1) {
          var _console3;
          (_console3 = console).warn.apply(_console3, arguments);
        }
      },
      error: function error() {
        if (["debug", "log", "warn", "error"].indexOf(configuration.logLevel) !== -1) {
          var _console4;
          (_console4 = console).error.apply(_console4, arguments);
        }
      }
    };
    function safeReactConstructor(Component, lastInstance) {
      try {
        if (lastInstance) {
          return new Component(lastInstance.props, lastInstance.context);
        }
        return new Component({}, {});
      } catch (e) {
      }
      return null;
    }
    function isNativeFunction(fn) {
      return typeof fn === "function" ? fn.toString().indexOf("[native code]") > 0 : false;
    }
    var identity = function identity2(a) {
      return a;
    };
    var indirectEval = eval;
    var doesSupportClasses = function() {
      try {
        indirectEval("class Test {}");
        return true;
      } catch (e) {
        return false;
      }
    }();
    var ES6ProxyComponentFactory = function ES6ProxyComponentFactory2(InitialParent, postConstructionAction) {
      return indirectEval("\n(function(InitialParent, postConstructionAction) {\n  return class " + (InitialParent.name || "HotComponent") + ' extends InitialParent {\n    /*\n     ! THIS IS NOT YOUR COMPONENT !\n     !  THIS IS REACT-HOT-LOADER  !\n  \n     this is a "' + InitialParent.name + '" component, patched by React-Hot-Loader\n     Sorry, but the real class code was hidden behind this facade\n     Please refer to https://github.com/gaearon/react-hot-loader for details...\n    */    \n    \n    constructor(props, context) {\n      super(props, context)\n      postConstructionAction.call(this)\n    }\n  }\n})\n')(InitialParent, postConstructionAction);
    };
    var ES5ProxyComponentFactory = function ES5ProxyComponentFactory2(InitialParent, postConstructionAction) {
      function ProxyComponent(props, context) {
        InitialParent.call(this, props, context);
        postConstructionAction.call(this);
      }
      ProxyComponent.prototype = Object.create(InitialParent.prototype);
      Object.setPrototypeOf(ProxyComponent, InitialParent);
      return ProxyComponent;
    };
    var proxyClassCreator = doesSupportClasses ? ES6ProxyComponentFactory : ES5ProxyComponentFactory;
    function getOwnKeys(target) {
      return [].concat(Object.getOwnPropertyNames(target), Object.getOwnPropertySymbols(target));
    }
    function shallowStringsEqual(a, b) {
      for (var key in a) {
        if (String(a[key]) !== String(b[key])) {
          return false;
        }
      }
      return true;
    }
    function deepPrototypeUpdate(dest, source) {
      var deepDest = Object.getPrototypeOf(dest);
      var deepSrc = Object.getPrototypeOf(source);
      if (deepDest && deepSrc && deepSrc !== deepDest) {
        deepPrototypeUpdate(deepDest, deepSrc);
      }
      if (source.prototype && source.prototype !== dest.prototype) {
        dest.prototype = source.prototype;
      }
    }
    function safeDefineProperty(target, key, props) {
      try {
        Object.defineProperty(target, key, props);
      } catch (e) {
        logger.warn("Error while wrapping", key, " -> ", e);
      }
    }
    var PREFIX = "__reactstandin__";
    var PROXY_KEY = PREFIX + "key";
    var GENERATION = PREFIX + "proxyGeneration";
    var REGENERATE_METHOD = PREFIX + "regenerateByEval";
    var UNWRAP_PROXY = PREFIX + "getCurrent";
    var CACHED_RESULT = PREFIX + "cachedResult";
    var PROXY_IS_MOUNTED = PREFIX + "isMounted";
    var RENDERED_GENERATION = "REACT_HOT_LOADER_RENDERED_GENERATION";
    var RESERVED_STATICS = ["length", "displayName", "name", "arguments", "caller", "prototype", "toString", "valueOf", "isStatelessFunctionalProxy", PROXY_KEY, UNWRAP_PROXY];
    function transferStaticProps(ProxyComponent, savedDescriptors, PreviousComponent, NextComponent) {
      Object.getOwnPropertyNames(ProxyComponent).forEach(function(key) {
        if (RESERVED_STATICS.indexOf(key) !== -1) {
          return;
        }
        var prevDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);
        var savedDescriptor = savedDescriptors[key];
        if (!shallowEqual(prevDescriptor, savedDescriptor)) {
          safeDefineProperty(NextComponent, key, prevDescriptor);
        }
      });
      Object.getOwnPropertyNames(NextComponent).forEach(function(key) {
        if (RESERVED_STATICS.indexOf(key) !== -1) {
          return;
        }
        var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(ProxyComponent, key);
        var savedDescriptor = savedDescriptors[key];
        if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {
          safeDefineProperty(NextComponent, key, prevDescriptor);
          return;
        }
        if (prevDescriptor && !savedDescriptor) {
          safeDefineProperty(ProxyComponent, key, prevDescriptor);
          return;
        }
        var nextDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextComponent, key), {
          configurable: true
        });
        savedDescriptors[key] = nextDescriptor;
        safeDefineProperty(ProxyComponent, key, nextDescriptor);
      });
      Object.getOwnPropertyNames(ProxyComponent).forEach(function(key) {
        if (RESERVED_STATICS.indexOf(key) !== -1) {
          return;
        }
        if (NextComponent.hasOwnProperty(key)) {
          return;
        }
        var proxyDescriptor = Object.getOwnPropertyDescriptor(ProxyComponent, key);
        if (proxyDescriptor && !proxyDescriptor.configurable) {
          return;
        }
        var prevDescriptor = PreviousComponent && Object.getOwnPropertyDescriptor(PreviousComponent, key);
        var savedDescriptor = savedDescriptors[key];
        if (prevDescriptor && savedDescriptor && !shallowEqual(savedDescriptor, prevDescriptor)) {
          return;
        }
        safeDefineProperty(ProxyComponent, key, {
          value: void 0
        });
      });
      return savedDescriptors;
    }
    function mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers) {
      var injectedCode = {};
      try {
        var nextInstance = safeReactConstructor(NextComponent, lastInstance);
        try {
          deepPrototypeUpdate(InitialComponent, NextComponent);
        } catch (e) {
        }
        var proxyInstance = safeReactConstructor(ProxyComponent, lastInstance);
        if (!nextInstance || !proxyInstance) {
          return injectedCode;
        }
        var mergedAttrs = _extends({}, proxyInstance, nextInstance);
        var hasRegenerate = proxyInstance[REGENERATE_METHOD];
        var ownKeys = getOwnKeys(Object.getPrototypeOf(ProxyComponent.prototype));
        Object.keys(mergedAttrs).forEach(function(key) {
          if (key.indexOf(PREFIX) === 0)
            return;
          var nextAttr = nextInstance[key];
          var prevAttr = proxyInstance[key];
          if (nextAttr) {
            if (isNativeFunction(nextAttr) || isNativeFunction(prevAttr)) {
              var isSameArity = nextAttr.length === prevAttr.length;
              var existsInPrototype = ownKeys.indexOf(key) >= 0 || ProxyComponent.prototype[key];
              if ((isSameArity || !prevAttr) && existsInPrototype) {
                if (hasRegenerate) {
                  injectedCode[key] = "Object.getPrototypeOf(this)['" + key + "'].bind(this)";
                } else {
                  logger.warn("React Hot Loader:,", "Non-controlled class", ProxyComponent.name, "contains a new native or bound function ", key, nextAttr, ". Unable to reproduce");
                }
              } else {
                logger.warn("React Hot Loader:", "Updated class ", ProxyComponent.name, "contains native or bound function ", key, nextAttr, ". Unable to reproduce, use arrow functions instead.", "(arity: " + nextAttr.length + "/" + prevAttr.length + ", proto: " + (existsInPrototype ? "yes" : "no"));
              }
              return;
            }
            var nextString = String(nextAttr);
            var injectedBefore = injectedMembers[key];
            var isArrow = nextString.indexOf("=>") >= 0;
            var isFunction = nextString.indexOf("function") >= 0 || isArrow;
            var referToThis = nextString.indexOf("this") >= 0;
            if (nextString !== String(prevAttr) || injectedBefore && nextString !== String(injectedBefore) || isArrow && referToThis) {
              if (!hasRegenerate) {
                if (!isFunction) {
                  injectedCode[key] = nextAttr;
                } else {
                  logger.warn("React Hot Loader:", " Updated class ", ProxyComponent.name, "had different code for", key, nextAttr, ". Unable to reproduce. Regeneration support needed.");
                }
              } else {
                injectedCode[key] = nextAttr;
              }
            }
          }
        });
      } catch (e) {
        logger.warn("React Hot Loader:", e);
      }
      return injectedCode;
    }
    function checkLifeCycleMethods(ProxyComponent, NextComponent) {
      try {
        var p1 = Object.getPrototypeOf(ProxyComponent.prototype);
        var p2 = NextComponent.prototype;
        reactLifeCycleMountMethods.forEach(function(key) {
          var d1 = Object.getOwnPropertyDescriptor(p1, key) || { value: p1[key] };
          var d2 = Object.getOwnPropertyDescriptor(p2, key) || { value: p2[key] };
          if (!shallowStringsEqual(d1, d2)) {
            logger.warn("React Hot Loader:", "You did update", ProxyComponent.name, "s lifecycle method", key, ". Unable to repeat");
          }
        });
      } catch (e) {
      }
    }
    function inject(target, currentGeneration, injectedMembers) {
      if (target[GENERATION] !== currentGeneration) {
        var hasRegenerate = !!target[REGENERATE_METHOD];
        Object.keys(injectedMembers).forEach(function(key) {
          try {
            if (hasRegenerate) {
              var usedThis = String(injectedMembers[key]).match(/_this([\d]+)/gi) || [];
              target[REGENERATE_METHOD](key, "(function REACT_HOT_LOADER_SANDBOX () {\n          var _this  = this; // common babel transpile\n          " + usedThis.map(function(name) {
                return "var " + name + " = this;";
              }) + "\n\n          return " + injectedMembers[key] + ";\n          }).call(this)");
            } else {
              target[key] = injectedMembers[key];
            }
          } catch (e) {
            logger.warn("React Hot Loader: Failed to regenerate method ", key, " of class ", target);
            logger.warn("got error", e);
          }
        });
        target[GENERATION] = currentGeneration;
      }
    }
    var has = Object.prototype.hasOwnProperty;
    var proxies = /* @__PURE__ */ new WeakMap();
    var resetClassProxies = function resetClassProxies2() {
      proxies = /* @__PURE__ */ new WeakMap();
    };
    var blackListedClassMembers = ["constructor", "render", "componentWillMount", "componentDidMount", "componentDidCatch", "componentWillReceiveProps", "componentWillUnmount", "hotComponentRender", "getInitialState", "getDefaultProps"];
    var defaultRenderOptions = {
      componentWillRender: identity,
      componentDidUpdate: function componentDidUpdate(result) {
        return result;
      },
      componentDidRender: function componentDidRender(result) {
        return result;
      }
    };
    var filteredPrototypeMethods = function filteredPrototypeMethods2(Proto) {
      return Object.getOwnPropertyNames(Proto).filter(function(prop) {
        var descriptor = Object.getOwnPropertyDescriptor(Proto, prop);
        return descriptor && prop.indexOf(PREFIX) !== 0 && blackListedClassMembers.indexOf(prop) < 0 && typeof descriptor.value === "function";
      });
    };
    var defineClassMember = function defineClassMember2(Class, methodName, methodBody) {
      return safeDefineProperty(Class.prototype, methodName, {
        configurable: true,
        writable: true,
        enumerable: false,
        value: methodBody
      });
    };
    var defineClassMembers = function defineClassMembers2(Class, methods) {
      return Object.keys(methods).forEach(function(methodName) {
        return defineClassMember(Class, methodName, methods[methodName]);
      });
    };
    var setSFPFlag = function setSFPFlag2(component, flag) {
      return safeDefineProperty(component, "isStatelessFunctionalProxy", {
        configurable: false,
        writable: false,
        enumerable: false,
        value: flag
      });
    };
    var copyMethodDescriptors = function copyMethodDescriptors2(target, source) {
      if (source) {
        var keys = Object.getOwnPropertyNames(source);
        keys.forEach(function(key) {
          return safeDefineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
        safeDefineProperty(target, "toString", {
          configurable: true,
          writable: false,
          enumerable: false,
          value: function toString() {
            return String(source);
          }
        });
      }
      return target;
    };
    var knownClassComponents = [];
    var forEachKnownClass = function forEachKnownClass2(cb) {
      return knownClassComponents.forEach(cb);
    };
    function createClassProxy(InitialComponent, proxyKey) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var renderOptions2 = _extends({}, defaultRenderOptions, options);
      var proxyConfig = _extends({}, configuration, options.proxy);
      var existingProxy = proxies.get(InitialComponent);
      if (existingProxy) {
        return existingProxy;
      }
      var CurrentComponent = void 0;
      var savedDescriptors = {};
      var injectedMembers = {};
      var proxyGeneration = 0;
      var classUpdatePostponed = null;
      var instancesCount = 0;
      var isFunctionalComponent = !isReactClass(InitialComponent);
      var lastInstance = null;
      function postConstructionAction() {
        this[GENERATION] = 0;
        lastInstance = this;
        if (classUpdatePostponed) {
          var callUpdate = classUpdatePostponed;
          classUpdatePostponed = null;
          callUpdate();
        }
        inject(this, proxyGeneration, injectedMembers);
      }
      function proxiedUpdate() {
        if (this) {
          inject(this, proxyGeneration, injectedMembers);
        }
      }
      function lifeCycleWrapperFactory(wrapperName) {
        var sideEffect = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : identity;
        return copyMethodDescriptors(function wrappedMethod() {
          proxiedUpdate.call(this);
          sideEffect(this);
          for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
            rest[_key] = arguments[_key];
          }
          return !isFunctionalComponent && CurrentComponent.prototype[wrapperName] && CurrentComponent.prototype[wrapperName].apply(this, rest);
        }, InitialComponent.prototype && InitialComponent.prototype[wrapperName]);
      }
      function methodWrapperFactory(wrapperName, realMethod) {
        return copyMethodDescriptors(function wrappedMethod() {
          for (var _len2 = arguments.length, rest = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            rest[_key2] = arguments[_key2];
          }
          return realMethod.apply(this, rest);
        }, realMethod);
      }
      var fakeBasePrototype = function fakeBasePrototype2(Proto) {
        return filteredPrototypeMethods(Proto).reduce(function(acc, key) {
          acc[key] = methodWrapperFactory(key, Proto[key]);
          return acc;
        }, {});
      };
      var componentDidMount = lifeCycleWrapperFactory("componentDidMount", function(target) {
        target[PROXY_IS_MOUNTED] = true;
        target[RENDERED_GENERATION] = get$1();
        instancesCount++;
      });
      var componentDidUpdate = lifeCycleWrapperFactory("componentDidUpdate", renderOptions2.componentDidUpdate);
      var componentWillUnmount = lifeCycleWrapperFactory("componentWillUnmount", function(target) {
        target[PROXY_IS_MOUNTED] = false;
        instancesCount--;
      });
      function hotComponentRender() {
        renderOptions2.componentWillRender(this);
        proxiedUpdate.call(this);
        var result = void 0;
        if (has.call(this, CACHED_RESULT)) {
          result = this[CACHED_RESULT];
          delete this[CACHED_RESULT];
        } else if (isFunctionalComponent) {
          result = CurrentComponent(this.props, this.context);
        } else {
          var renderMethod = CurrentComponent.prototype.render || this.render;
          if (renderMethod === proxiedRender) {
            throw new Error("React-Hot-Loader: you are trying to render Component without .render method");
          }
          result = renderMethod.apply(
            this,
            arguments
          );
        }
        return renderOptions2.componentDidRender.call(this, result);
      }
      function hotComponentUpdate() {
        renderOptions2.componentWillRender(this);
        proxiedUpdate.call(this);
      }
      function proxiedRender() {
        renderOptions2.componentWillRender(this);
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return hotComponentRender.call.apply(hotComponentRender, [this].concat(args));
      }
      var defineProxyMethods = function defineProxyMethods2(Proxy) {
        var Base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        defineClassMembers(Proxy, _extends({}, fakeBasePrototype(Base), proxyConfig.pureRender ? {} : { render: proxiedRender }, {
          hotComponentRender,
          hotComponentUpdate,
          componentDidMount,
          componentDidUpdate,
          componentWillUnmount
        }));
      };
      var _ProxyFacade = void 0;
      var ProxyComponent = null;
      var proxy = void 0;
      if (!isFunctionalComponent) {
        ProxyComponent = proxyClassCreator(InitialComponent, postConstructionAction);
        defineProxyMethods(ProxyComponent, InitialComponent.prototype);
        knownClassComponents.push(ProxyComponent);
        _ProxyFacade = ProxyComponent;
      } else if (!proxyConfig.allowSFC) {
        proxyConfig.pureRender = false;
        ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);
        defineProxyMethods(ProxyComponent);
        _ProxyFacade = ProxyComponent;
      } else {
        _ProxyFacade = function ProxyFacade(props, context) {
          var result = CurrentComponent(props, context);
          if (isReactClassInstance(result)) {
            ProxyComponent = null;
            transferStaticProps(_ProxyFacade, savedDescriptors, null, CurrentComponent);
            return result;
          }
          if (proxyConfig.pureSFC) {
            if (!CurrentComponent.contextTypes) {
              if (!_ProxyFacade.isStatelessFunctionalProxy) {
                setSFPFlag(_ProxyFacade, true);
              }
              return renderOptions2.componentDidRender(result);
            }
          }
          setSFPFlag(_ProxyFacade, false);
          proxyConfig.pureRender = false;
          ProxyComponent = proxyClassCreator(React.Component, postConstructionAction);
          defineProxyMethods(ProxyComponent);
          var determinateResult = new ProxyComponent(props, context);
          determinateResult[CACHED_RESULT] = result;
          return determinateResult;
        };
      }
      function get$$1() {
        return _ProxyFacade;
      }
      function getCurrent() {
        return CurrentComponent;
      }
      safeDefineProperty(_ProxyFacade, UNWRAP_PROXY, {
        configurable: false,
        writable: false,
        enumerable: false,
        value: getCurrent
      });
      safeDefineProperty(_ProxyFacade, PROXY_KEY, {
        configurable: false,
        writable: false,
        enumerable: false,
        value: proxyKey
      });
      safeDefineProperty(_ProxyFacade, "toString", {
        configurable: true,
        writable: false,
        enumerable: false,
        value: function toString() {
          return String(CurrentComponent);
        }
      });
      function update(NextComponent) {
        if (typeof NextComponent !== "function") {
          throw new Error("Expected a constructor.");
        }
        if (NextComponent === CurrentComponent) {
          return false;
        }
        var existingProxy2 = proxies.get(NextComponent);
        if (existingProxy2) {
          return false;
        }
        isFunctionalComponent = !isReactClass(NextComponent);
        proxies.set(NextComponent, proxy);
        proxyGeneration++;
        var PreviousComponent = CurrentComponent;
        CurrentComponent = NextComponent;
        var displayName = getComponentDisplayName(CurrentComponent);
        safeDefineProperty(_ProxyFacade, "displayName", {
          configurable: true,
          writable: false,
          enumerable: true,
          value: displayName
        });
        if (ProxyComponent) {
          safeDefineProperty(ProxyComponent, "name", {
            value: displayName
          });
        }
        savedDescriptors = transferStaticProps(_ProxyFacade, savedDescriptors, PreviousComponent, NextComponent);
        if (isFunctionalComponent || !ProxyComponent)
          ;
        else {
          var classHotReplacement = function classHotReplacement2() {
            checkLifeCycleMethods(ProxyComponent, NextComponent);
            if (proxyGeneration > 1) {
              getElementCloseHook(ProxyComponent);
              filteredPrototypeMethods(ProxyComponent.prototype).forEach(function(methodName) {
                if (!has.call(NextComponent.prototype, methodName)) {
                  delete ProxyComponent.prototype[methodName];
                }
              });
            }
            Object.setPrototypeOf(ProxyComponent.prototype, NextComponent.prototype);
            defineProxyMethods(ProxyComponent, NextComponent.prototype);
            if (proxyGeneration > 1) {
              injectedMembers = mergeComponents(ProxyComponent, NextComponent, InitialComponent, lastInstance, injectedMembers);
              getElementComparisonHook(ProxyComponent);
            }
          };
          if (instancesCount > 0) {
            classHotReplacement();
          } else {
            classUpdatePostponed = classHotReplacement;
          }
        }
        return true;
      }
      update(InitialComponent);
      var dereference = function dereference2() {
        proxies.delete(InitialComponent);
        proxies.delete(_ProxyFacade);
        proxies.delete(CurrentComponent);
      };
      proxy = { get: get$$1, update, dereference, getCurrent: function getCurrent2() {
        return CurrentComponent;
      } };
      proxies.set(InitialComponent, proxy);
      proxies.set(_ProxyFacade, proxy);
      safeDefineProperty(proxy, UNWRAP_PROXY, {
        configurable: false,
        writable: false,
        enumerable: false,
        value: getCurrent
      });
      return proxy;
    }
    var generation = 1;
    var hotComparisonCounter = 0;
    var hotComparisonRuns = 0;
    var hotReplacementGeneration = 0;
    var nullFunction = function nullFunction2() {
      return {};
    };
    var onHotComparisonOpen = nullFunction;
    var onHotComparisonElement = nullFunction;
    var onHotComparisonClose = nullFunction;
    var setComparisonHooks = function setComparisonHooks2(open, element, close) {
      onHotComparisonOpen = open;
      onHotComparisonElement = element;
      onHotComparisonClose = close;
    };
    var getElementComparisonHook = function getElementComparisonHook2(component) {
      return onHotComparisonElement(component);
    };
    var getElementCloseHook = function getElementCloseHook2(component) {
      return onHotComparisonClose(component);
    };
    var hotComparisonOpen = function hotComparisonOpen2() {
      return hotComparisonCounter > 0 && hotComparisonRuns > 0 && hotReplacementGeneration > 0;
    };
    var openGeneration = function openGeneration2() {
      return forEachKnownClass(onHotComparisonElement);
    };
    var closeGeneration = function closeGeneration2() {
      return forEachKnownClass(onHotComparisonClose);
    };
    var incrementHot = function incrementHot2() {
      if (!hotComparisonCounter) {
        openGeneration();
        onHotComparisonOpen();
      }
      hotComparisonCounter++;
    };
    var decrementHot = function decrementHot2() {
      hotComparisonCounter--;
      if (!hotComparisonCounter) {
        closeGeneration();
        hotComparisonRuns++;
      }
    };
    var enterHotUpdate = function enterHotUpdate2() {
      Promise.resolve(incrementHot()).then(function() {
        return setTimeout(decrementHot, 0);
      });
    };
    var increment = function increment2() {
      enterHotUpdate();
      return generation++;
    };
    var get$1 = function get() {
      return generation;
    };
    var incrementHotGeneration = function incrementHotGeneration2() {
      return hotReplacementGeneration++;
    };
    var getHotGeneration = function getHotGeneration2() {
      return hotReplacementGeneration;
    };
    var UNDEFINED_NAMES = {
      Unknown: true,
      Component: true
    };
    var areNamesEqual = function areNamesEqual2(a, b) {
      return a === b || UNDEFINED_NAMES[a] && UNDEFINED_NAMES[b];
    };
    var isFunctional = function isFunctional2(fn) {
      return typeof fn === "function";
    };
    var getTypeOf = function getTypeOf2(type) {
      if (isReactClass(type))
        return "ReactComponent";
      if (isFunctional(type))
        return "StatelessFunctional";
      return "Fragment";
    };
    function clearStringFast(str) {
      return str.length < 12 ? str : (" " + str).slice(1);
    }
    var haveTextSimilarity = function haveTextSimilarity2(a, b) {
      return a === b || levenshtein.get(clearStringFast(a), clearStringFast(b)) < a.length * 0.2;
    };
    var getBaseProto = function getBaseProto2(source) {
      return source.prototype.hotComponentRender ? Object.getPrototypeOf(source.prototype) : source.prototype;
    };
    var equalClasses = function equalClasses2(a, b) {
      var prototypeA = getBaseProto(a);
      var prototypeB = getBaseProto(b);
      var hits = 0;
      var misses = 0;
      var comparisons = 0;
      Object.getOwnPropertyNames(prototypeA).forEach(function(key) {
        var descriptorA = Object.getOwnPropertyDescriptor(prototypeA, key);
        var valueA = descriptorA && (descriptorA.value || descriptorA.get || descriptorA.set);
        var descriptorB = Object.getOwnPropertyDescriptor(prototypeB, key);
        var valueB = descriptorB && (descriptorB.value || descriptorB.get || descriptorB.set);
        if (typeof valueA === "function" && key !== "constructor") {
          comparisons++;
          if (haveTextSimilarity(String(valueA), String(valueB))) {
            hits++;
          } else {
            misses++;
            if (key === "render") {
              misses++;
            }
          }
        }
      });
      return hits > 0 && misses <= 1 || comparisons === 0;
    };
    var areSwappable = function areSwappable2(a, b) {
      if (getIdByType(b) && getIdByType(a) === getIdByType(b)) {
        return true;
      }
      if (getTypeOf(a) !== getTypeOf(b)) {
        return false;
      }
      if (isReactClass(a)) {
        return areNamesEqual(getComponentDisplayName(a), getComponentDisplayName(b)) && equalClasses(a, b);
      }
      if (isFunctional(a)) {
        var nameA = getComponentDisplayName(a);
        if (!areNamesEqual(nameA, getComponentDisplayName(b))) {
          return false;
        }
        return nameA !== "Component" || haveTextSimilarity(String(a), String(b));
      }
      return false;
    };
    function merge() {
      var acc = {};
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      for (var _iterator = sources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var source = _ref;
        if (source instanceof Array) {
          if (!(acc instanceof Array)) {
            acc = [];
          }
          acc = [].concat(acc, source);
        } else if (source instanceof Object) {
          for (var _iterator2 = Object.keys(source), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
            var _babelHelpers$extends;
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var key = _ref2;
            var value = source[key];
            if (value instanceof Object && key in acc) {
              value = merge(acc[key], value);
            }
            acc = _extends({}, acc, (_babelHelpers$extends = {}, _babelHelpers$extends[key] = value, _babelHelpers$extends));
          }
        }
      }
      return acc;
    }
    var signatures = void 0;
    var proxiesByID = void 0;
    var blackListedProxies = void 0;
    var registeredComponents = void 0;
    var idsByType = void 0;
    var elementCount = 0;
    var renderOptions = {};
    var componentOptions = void 0;
    var generateTypeId = function generateTypeId2() {
      return "auto-" + elementCount++;
    };
    var getIdByType = function getIdByType2(type) {
      return idsByType.get(type);
    };
    var isProxyType = function isProxyType2(type) {
      return type[PROXY_KEY];
    };
    var getProxyById = function getProxyById2(id) {
      return proxiesByID[id];
    };
    var getProxyByType = function getProxyByType2(type) {
      return getProxyById(getIdByType(type));
    };
    var registerComponent = function registerComponent2(type) {
      return registeredComponents.set(type, 1);
    };
    var isRegisteredComponent = function isRegisteredComponent2(type) {
      return registeredComponents.has(type);
    };
    var setStandInOptions = function setStandInOptions2(options) {
      renderOptions = options;
    };
    var updateFunctionProxyById = function updateFunctionProxyById2(id, type, updater) {
      idsByType.set(type, id);
      var proxy = proxiesByID[id];
      if (!proxy) {
        proxiesByID[id] = type;
      }
      updater(proxiesByID[id], type);
      return proxiesByID[id];
    };
    var updateProxyById = function updateProxyById2(id, type) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!id) {
        return null;
      }
      idsByType.set(type, id);
      if (!proxiesByID[id]) {
        proxiesByID[id] = createClassProxy(type, id, merge({}, renderOptions, { proxy: componentOptions.get(type) || {} }, options));
      } else if (proxiesByID[id].update(type)) {
        incrementHotGeneration();
      }
      return proxiesByID[id];
    };
    var createProxyForType = function createProxyForType2(type, options) {
      return getProxyByType(type) || updateProxyById(generateTypeId(), type, options);
    };
    var isColdType = function isColdType2(type) {
      return blackListedProxies.has(type);
    };
    var isTypeBlacklisted = function isTypeBlacklisted2(type) {
      return isColdType(type) || isCompositeComponent(type) && (configuration.ignoreSFC && !isReactClass(type) || configuration.ignoreComponents && isReactClass(type));
    };
    var blacklistByType = function blacklistByType2(type) {
      return blackListedProxies.set(type, true);
    };
    var setComponentOptions = function setComponentOptions2(component, options) {
      return componentOptions.set(component, options);
    };
    var addSignature = function addSignature2(type, signature) {
      return signatures.set(type, signature);
    };
    var getSignature = function getSignature2(type) {
      return signatures.get(type);
    };
    var resetProxies = function resetProxies2() {
      proxiesByID = {};
      idsByType = /* @__PURE__ */ new WeakMap();
      blackListedProxies = /* @__PURE__ */ new WeakMap();
      registeredComponents = /* @__PURE__ */ new WeakMap();
      componentOptions = /* @__PURE__ */ new WeakMap();
      signatures = /* @__PURE__ */ new WeakMap();
      resetClassProxies();
    };
    resetProxies();
    var tune = {
      allowSFC: false
    };
    var preactAdapter = function preactAdapter2(instance, resolveType2) {
      var oldHandler = instance.options.vnode;
      setConfiguration(tune);
      instance.options.vnode = function(vnode) {
        if (vnode.type) {
          vnode.type = resolveType2(vnode.type);
        } else if (vnode.nodeName) {
          vnode.nodeName = resolveType2(vnode.nodeName);
        }
        if (oldHandler) {
          oldHandler(vnode);
        }
      };
    };
    var lastError = [];
    var overlayStyle = {
      position: "fixed",
      left: 0,
      top: 0,
      right: 0,
      backgroundColor: "rgba(255,200,200,0.9)",
      color: "#000",
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
      fontSize: "12px",
      margin: 0,
      padding: "16px",
      maxHeight: "50%",
      overflow: "auto",
      zIndex: 1e4
    };
    var inlineErrorStyle = {
      backgroundColor: "#FEE"
    };
    var liCounter = {
      position: "absolute",
      left: "10px"
    };
    var listStyle = {};
    var EmptyErrorPlaceholder = function EmptyErrorPlaceholder2(_ref) {
      var component = _ref.component;
      return React__default.createElement(
        "span",
        { style: inlineErrorStyle, role: "img", "aria-label": "Rect-Hot-Loader Error" },
        "\u269B\uFE0F\u{1F525}\u{1F915} (",
        component ? getComponentDisplayName(component.constructor || component) : "Unknown location",
        ")",
        component && component.retryHotLoaderError && React__default.createElement(
          "button",
          { onClick: function onClick() {
            return component.retryHotLoaderError();
          }, title: "Retry" },
          "\u27F3"
        )
      );
    };
    var errorHeader = function errorHeader2(component, componentStack) {
      if (component || componentStack) {
        return React__default.createElement(
          "span",
          null,
          "(",
          component ? getComponentDisplayName(component.constructor || component) : "Unknown location",
          component && ", ",
          componentStack && componentStack.split("\n").filter(Boolean)[0],
          ")"
        );
      }
      return null;
    };
    var mapError = function mapError2(_ref2) {
      var error = _ref2.error, errorInfo = _ref2.errorInfo, component = _ref2.component;
      if (!error) {
        error = { message: "undefined error" };
      }
      return React__default.createElement(
        React__default.Fragment,
        null,
        React__default.createElement(
          "p",
          { style: { color: "red" } },
          errorHeader(component, errorInfo && errorInfo.componentStack),
          " ",
          error.toString ? error.toString() : error && error.message || "undefined error"
        ),
        errorInfo && errorInfo.componentStack ? React__default.createElement(
          "div",
          null,
          React__default.createElement(
            "div",
            null,
            "Stack trace:"
          ),
          React__default.createElement(
            "ul",
            { style: { color: "red", marginTop: "10px" } },
            error.stack.split("\n").slice(1, 2).map(function(line, i) {
              return React__default.createElement(
                "li",
                { key: String(i) },
                line
              );
            }),
            React__default.createElement("hr", null),
            errorInfo.componentStack.split("\n").filter(Boolean).map(function(line, i) {
              return React__default.createElement(
                "li",
                { key: String(i) },
                line
              );
            })
          )
        ) : error.stack && React__default.createElement(
          "div",
          null,
          React__default.createElement(
            "div",
            null,
            "Stack trace:"
          ),
          React__default.createElement(
            "ul",
            { style: { color: "red", marginTop: "10px" } },
            error.stack.split("\n").map(function(line, i) {
              return React__default.createElement(
                "li",
                { key: String(i) },
                line
              );
            })
          )
        )
      );
    };
    var ErrorOverlay = function(_React$Component) {
      inherits(ErrorOverlay2, _React$Component);
      function ErrorOverlay2() {
        var _temp, _this, _ret;
        classCallCheck(this, ErrorOverlay2);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _ret = (_temp = (_this = possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
          visible: true
        }, _this.toggle = function() {
          return _this.setState({ visible: !_this.state.visible });
        }, _this.retry = function() {
          return _this.setState(function() {
            var errors = _this.props.errors;
            enterHotUpdate();
            clearExceptions();
            errors.map(function(_ref3) {
              var component = _ref3.component;
              return component;
            }).filter(Boolean).filter(function(_ref4) {
              var retryHotLoaderError2 = _ref4.retryHotLoaderError;
              return !!retryHotLoaderError2;
            }).forEach(function(component) {
              return component.retryHotLoaderError();
            });
            return {};
          });
        }, _temp), possibleConstructorReturn(_this, _ret);
      }
      ErrorOverlay2.prototype.render = function render2() {
        var errors = this.props.errors;
        if (!errors.length) {
          return null;
        }
        var visible = this.state.visible;
        return React__default.createElement(
          "div",
          { style: overlayStyle },
          React__default.createElement(
            "h2",
            { style: { margin: 0 } },
            "\u269B\uFE0F\u{1F525}\u{1F62D}: hot update was not successful ",
            React__default.createElement(
              "button",
              { onClick: this.toggle },
              visible ? "collapse" : "expand"
            ),
            React__default.createElement(
              "button",
              { onClick: this.retry },
              "Retry"
            )
          ),
          visible && React__default.createElement(
            "ul",
            { style: listStyle },
            errors.map(function(err, i) {
              return React__default.createElement(
                "li",
                { key: i },
                React__default.createElement(
                  "span",
                  { style: liCounter },
                  "(",
                  i + 1,
                  "/",
                  errors.length,
                  ")"
                ),
                mapError(err)
              );
            })
          )
        );
      };
      return ErrorOverlay2;
    }(React__default.Component);
    var initErrorOverlay = function initErrorOverlay2() {
      if (typeof document === "undefined" || !document.body) {
        return;
      }
      var div = document.querySelector(".react-hot-loader-error-overlay");
      if (!div) {
        div = document.createElement("div");
        div.className = "react-hot-loader-error-overlay";
        document.body.appendChild(div);
      }
      if (lastError.length) {
        var Overlay = configuration.ErrorOverlay || ErrorOverlay;
        ReactDOM.render(React__default.createElement(Overlay, { errors: lastError }), div);
      } else {
        div.parentNode.removeChild(div);
      }
    };
    function clearExceptions() {
      if (lastError.length) {
        lastError = [];
        initErrorOverlay();
      }
    }
    function logException(error, errorInfo, component) {
      console.error(error);
      lastError.push({ error, errorInfo, component });
      initErrorOverlay();
    }
    var hotRenderWithHooks = ReactDOM.hotRenderWithHooks || function(fiber, render2) {
      return render2();
    };
    function pushStack(stack, node) {
      stack.type = node.type;
      stack.elementType = node.elementType || node.type;
      stack.children = [];
      stack.instance = typeof node.type === "function" ? node.stateNode : stack;
      stack.fiber = node;
      if (!stack.instance) {
        stack.instance = {
          SFC_fake: stack.type,
          props: {},
          render: function render2() {
            return hotRenderWithHooks(node, function() {
              return stack.type(stack.instance.props);
            });
          }
        };
      }
    }
    function hydrateFiberStack(node, stack) {
      pushStack(stack, node);
      if (node.child) {
        var child = node.child;
        do {
          var childStack = {};
          hydrateFiberStack(child, childStack);
          stack.children.push(childStack);
          child = child.sibling;
        } while (child);
      }
    }
    function pushState(stack, type, instance) {
      stack.type = type;
      stack.elementType = type;
      stack.children = [];
      stack.instance = instance || stack;
      if (typeof type === "function" && type.isStatelessFunctionalProxy) {
        stack.instance = {
          SFC_fake: type,
          props: {},
          render: function render2() {
            return type(stack.instance.props);
          }
        };
      }
    }
    function hydrateLegacyStack(node, stack) {
      if (node._currentElement) {
        pushState(stack, node._currentElement.type, node._instance || stack);
      }
      if (node._renderedComponent) {
        var childStack = {};
        hydrateLegacyStack(node._renderedComponent, childStack);
        stack.children.push(childStack);
      } else if (node._renderedChildren) {
        Object.keys(node._renderedChildren).forEach(function(key) {
          var childStack2 = {};
          hydrateLegacyStack(node._renderedChildren[key], childStack2);
          stack.children.push(childStack2);
        });
      }
    }
    var shouldNotPatchComponent = function shouldNotPatchComponent2(type) {
      return isTypeBlacklisted(type);
    };
    function resolveUtility(type) {
      if ((typeof type === "undefined" ? "undefined" : _typeof(type)) === "object") {
        if (configuration.integratedComparator) {
          return type;
        }
        var element = { type };
        if (isLazyType(element) || isMemoType(element) || isForwardType(element) || isContextType(element)) {
          return getProxyByType(type) || type;
        }
      }
      return void 0;
    }
    function resolveComponent(type) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var existingProxy = getProxyByType(type);
      if (shouldNotPatchComponent(type)) {
        return existingProxy ? existingProxy.getCurrent() : type;
      }
      if (!existingProxy && configuration.onComponentCreate) {
        configuration.onComponentCreate(type, getComponentDisplayName(type));
        if (shouldNotPatchComponent(type)) {
          return type;
        }
      }
      var proxy = internalConfiguration.disableProxyCreation ? existingProxy : createProxyForType(type, options);
      return proxy ? proxy.get() : void 0;
    }
    function resolveProxy(type) {
      if (isProxyType(type)) {
        return type;
      }
      return void 0;
    }
    function resolveNotComponent(type) {
      if (!isCompositeComponent(type)) {
        return type;
      }
      return void 0;
    }
    var getLatestTypeVersion = function getLatestTypeVersion2(type) {
      var existingProxy = getProxyByType(type);
      return existingProxy && existingProxy.getCurrent && existingProxy.getCurrent();
    };
    var resolveSimpleType = function resolveSimpleType2(type) {
      if (!type) {
        return type;
      }
      var simpleResult = resolveProxy(type) || resolveUtility(type) || resolveNotComponent(type);
      if (simpleResult) {
        return simpleResult;
      }
      var lastType = getLatestTypeVersion(type);
      return lastType || type;
    };
    var resolveType = function resolveType2(type) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!type) {
        return type;
      }
      return resolveProxy(type) || resolveUtility(type) || resolveNotComponent(type) || resolveComponent(type, options) || type;
    };
    function getReactStack(instance) {
      var rootNode = getInternalInstance(instance);
      var stack = {};
      if (rootNode) {
        var isFiber = typeof rootNode.tag === "number";
        if (isFiber) {
          hydrateFiberStack(rootNode, stack);
        } else {
          hydrateLegacyStack(rootNode, stack);
        }
      }
      return stack;
    }
    var markUpdate = function markUpdate2(_ref) {
      var fiber = _ref.fiber;
      if (!fiber || typeof fiber.type === "string") {
        return;
      }
      var mostResentType = resolveType(fiber.type) || fiber.type;
      fiber.type = mostResentType;
      fiber.expirationTime = 1;
      if (fiber.alternate) {
        fiber.alternate.expirationTime = 1;
        fiber.alternate.type = fiber.type;
      }
      if (fiber.memoizedProps && _typeof(fiber.memoizedProps) === "object") {
        fiber.memoizedProps = _extends({
          cacheBusterProp: true
        }, fiber.memoizedProps);
      }
      if (fiber.stateNode)
        ;
    };
    var cleanupReact = function cleanupReact2() {
      if (ReactDOM.hotCleanup) {
        ReactDOM.hotCleanup();
      }
    };
    var deepMarkUpdate = function deepMarkUpdate2(stack) {
      markUpdate(stack);
      if (stack.children) {
        stack.children.forEach(deepMarkUpdate2);
      }
    };
    var renderStack = [];
    var stackReport = function stackReport2() {
      var rev = renderStack.slice().reverse();
      logger.warn("in", rev[0].name, rev);
    };
    var emptyMap = /* @__PURE__ */ new Map();
    var stackContext = function stackContext2() {
      return (renderStack[renderStack.length - 1] || {}).context || emptyMap;
    };
    var shouldUseRenderMethod = function shouldUseRenderMethod2(fn) {
      return fn && (isReactClassInstance(fn) || fn.SFC_fake);
    };
    var getElementType$1 = function getElementType$$1(child) {
      return child.type[UNWRAP_PROXY] ? child.type[UNWRAP_PROXY]() : child.type;
    };
    var filterNullArray = function filterNullArray2(a) {
      if (!a)
        return [];
      return a.filter(function(x) {
        return !!x;
      });
    };
    var unflatten = function unflatten2(a) {
      return a.reduce(function(acc, a2) {
        if (Array.isArray(a2)) {
          acc.push.apply(acc, unflatten2(a2));
        } else {
          acc.push(a2);
        }
        return acc;
      }, []);
    };
    var isArray = function isArray2(fn) {
      return Array.isArray(fn);
    };
    var asArray = function asArray2(a) {
      return isArray(a) ? a : [a];
    };
    var render = function render2(component, stack) {
      if (!component) {
        return [];
      }
      if (component.hotComponentUpdate) {
        component.hotComponentUpdate();
      }
      if (shouldUseRenderMethod(component)) {
        return component.hotComponentRender ? component.hotComponentRender() : component.render();
      }
      if (isForwardType(component)) {
        return hotRenderWithHooks(stack.fiber, function() {
          return component.type.render(component.props, null);
        });
      }
      if (isArray(component)) {
        return component.map(render2);
      }
      if (component.children) {
        return component.children;
      }
      return [];
    };
    var NO_CHILDREN = { children: [] };
    var mapChildren = function mapChildren2(children, instances) {
      return {
        children: children.filter(function(c) {
          return c;
        }).map(function(child, index) {
          if ((typeof child === "undefined" ? "undefined" : _typeof(child)) !== "object" || child.isMerged) {
            return child;
          }
          var instanceLine = instances[index] || {};
          var oldChildren = asArray(instanceLine.children || []);
          if (Array.isArray(child)) {
            return _extends({
              type: null
            }, mapChildren2(child, oldChildren));
          }
          var newChildren = asArray(child.props && child.props.children || child.children || []);
          var nextChildren = child.type !== "function" && oldChildren.length && mapChildren2(newChildren, oldChildren);
          return _extends({
            nextProps: child.props,
            isMerged: true
          }, instanceLine, nextChildren || {}, {
            type: child.type
          });
        })
      };
    };
    var mergeInject = function mergeInject2(a, b, instance) {
      if (a && !Array.isArray(a)) {
        return mergeInject2([a], b);
      }
      if (b && !Array.isArray(b)) {
        return mergeInject2(a, [b]);
      }
      if (!a || !b) {
        return NO_CHILDREN;
      }
      if (a.length === b.length) {
        return mapChildren(a, b);
      }
      var nonNullA = filterNullArray(a);
      if (nonNullA.length === b.length) {
        return mapChildren(nonNullA, b);
      }
      var flatA = unflatten(nonNullA);
      var flatB = unflatten(b);
      if (flatA.length === flatB.length) {
        return mapChildren(flatA, flatB);
      }
      if (flatB.length === 0 && flatA.length === 1 && _typeof(flatA[0]) !== "object")
        ;
      else if (!configuration.IS_REACT_MERGE_ENABLED) {
        logger.warn("React-hot-loader: unable to merge ", a, "and children of ", instance);
        stackReport();
      }
      return NO_CHILDREN;
    };
    var transformFlowNode = function transformFlowNode2(flow) {
      return flow.reduce(function(acc, node) {
        if (node && isFragmentNode(node)) {
          if (node.props && node.props.children) {
            return [].concat(acc, filterNullArray(asArray(node.props.children)));
          }
          if (node.children) {
            return [].concat(acc, filterNullArray(asArray(node.children)));
          }
        }
        return [].concat(acc, [node]);
      }, []);
    };
    var scheduledUpdates = [];
    var scheduledUpdate = 0;
    var flushScheduledUpdates = function flushScheduledUpdates2() {
      var instances = scheduledUpdates;
      scheduledUpdates = [];
      scheduledUpdate = 0;
      instances.forEach(function(instance) {
        return instance[PROXY_IS_MOUNTED] && updateInstance(instance);
      });
    };
    var unscheduleUpdate = function unscheduleUpdate2(instance) {
      scheduledUpdates = scheduledUpdates.filter(function(inst) {
        return inst !== instance;
      });
    };
    var scheduleInstanceUpdate = function scheduleInstanceUpdate2(instance) {
      scheduledUpdates.push(instance);
      if (!scheduledUpdate) {
        scheduledUpdate = setTimeout(flushScheduledUpdates, 4);
      }
    };
    var hotReplacementRender = function hotReplacementRender2(instance, stack) {
      if (isReactClassInstance(instance)) {
        var type = getElementType$1(stack);
        renderStack.push({
          name: getComponentDisplayName(type),
          type,
          props: stack.instance.props,
          context: stackContext()
        });
      }
      try {
        var flow = transformFlowNode(filterNullArray(asArray(render(instance, stack))));
        var children = stack.children;
        flow.forEach(function(child, index) {
          var childType = child.type;
          var stackChild = children[index];
          var next = function next2(instance2) {
            var realProps = instance2.props;
            var nextProps = _extends({}, realProps, child.nextProps || {}, child.props || {});
            if (isReactClassInstance(instance2) && instance2.componentWillUpdate) {
              instance2.componentWillUpdate(_extends({}, realProps), instance2.state);
            }
            instance2.props = nextProps;
            hotReplacementRender2(instance2, stackChild);
            instance2.props = realProps;
          };
          if ((typeof child === "undefined" ? "undefined" : _typeof(child)) !== "object" || !stackChild || !stackChild.instance) {
            if (stackChild && stackChild.children && stackChild.children.length) {
              logger.error("React-hot-loader: reconciliation failed", "could not dive into [", child, "] while some elements are still present in the tree.");
              stackReport();
            }
            return;
          }
          if ((typeof childType === "undefined" ? "undefined" : _typeof(childType)) !== _typeof(stackChild.elementType)) {
            if (childType && stackChild.type) {
              logger.warn("React-hot-loader: got ", childType, "instead of", stackChild.type);
              stackReport();
            }
            return;
          }
          if (isMemoType(child) || isLazyType(child)) {
            if (stackChild.children && stackChild.children[0]) {
              scheduleInstanceUpdate(stackChild.children[0].instance);
            }
            childType = childType.type || childType;
          }
          if (isForwardType(child)) {
            next(stackChild.instance);
          } else if (isContextConsumer(child)) {
            try {
              var contextValue = stackContext().get(getContextProvider(childType));
              next({
                children: (child.props ? child.props.children : child.children[0])(contextValue !== void 0 ? contextValue : childType[CONTEXT_CURRENT_VALUE])
              });
            } catch (e) {
            }
          } else if (typeof childType !== "function") {
            var childName = childType ? getComponentDisplayName(childType) : "empty";
            var extraContext = stackContext();
            if (isContextProvider(child)) {
              extraContext = new Map(extraContext);
              extraContext.set(getContextProvider(childType), _extends({}, child.nextProps || {}, child.props || {}).value);
              childName = "ContextProvider";
            }
            renderStack.push({
              name: childName,
              type: childType,
              props: stack.instance.props,
              context: extraContext
            });
            next(
              mergeInject(transformFlowNode(asArray(child.props ? child.props.children : child.children)), stackChild.instance.children, stackChild.instance)
            );
            renderStack.pop();
          } else {
            if (childType === stackChild.type) {
              next(stackChild.instance);
            } else {
              var _childType = getElementType$1(child);
              if (isMemoType(child)) {
                _childType = _childType.type || _childType;
              }
              if (!stackChild.type[PROXY_KEY]) {
                if (!configuration.IS_REACT_MERGE_ENABLED) {
                  if (isTypeBlacklisted(stackChild.type)) {
                    logger.warn("React-hot-loader: cold element got updated ", stackChild.type);
                  }
                }
              }
              if (isRegisteredComponent(_childType) || isRegisteredComponent(stackChild.type)) {
                if (resolveType(_childType) === resolveType(stackChild.type)) {
                  next(stackChild.instance);
                }
              } else if (areSwappable(_childType, stackChild.type)) {
                updateProxyById(stackChild.type[PROXY_KEY] || getIdByType(stackChild.type), _childType);
                next(stackChild.instance);
              } else {
                logger.warn("React-hot-loader: a " + getComponentDisplayName(_childType) + " was found where a " + getComponentDisplayName(stackChild) + " was expected.\n          " + _childType);
                stackReport();
              }
            }
            scheduleInstanceUpdate(stackChild.instance);
          }
        });
      } catch (e) {
        if (e.then)
          ;
        else {
          logger.warn("React-hot-loader: run time error during reconciliation", e);
        }
      }
      if (isReactClassInstance(instance)) {
        renderStack.pop();
      }
    };
    var hotReplacementRender$1 = function(instance, stack) {
      if (configuration.disableHotRenderer) {
        return;
      }
      try {
        internalConfiguration.disableProxyCreation = true;
        renderStack = [];
        hotReplacementRender(instance, stack);
      } catch (e) {
        logger.warn("React-hot-loader: reconcilation failed due to error", e);
      } finally {
        internalConfiguration.disableProxyCreation = false;
      }
    };
    var reconcileHotReplacement = function reconcileHotReplacement2(ReactInstance) {
      var stack = getReactStack(ReactInstance);
      hotReplacementRender$1(ReactInstance, stack);
      cleanupReact();
      deepMarkUpdate(stack);
    };
    var renderReconciler = function renderReconciler2(target, force) {
      var currentGeneration = get$1();
      var componentGeneration = target[RENDERED_GENERATION];
      target[RENDERED_GENERATION] = currentGeneration;
      if (!internalConfiguration.disableProxyCreation) {
        if ((componentGeneration || force) && componentGeneration !== currentGeneration) {
          enterHotUpdate();
          reconcileHotReplacement(target);
          return true;
        }
      }
      return false;
    };
    function asyncReconciledRender(target) {
      renderReconciler(target, false);
    }
    function proxyWrapper(element) {
      if (!internalConfiguration.disableProxyCreation) {
        unscheduleUpdate(this);
      }
      if (!element) {
        return element;
      }
      if (Array.isArray(element)) {
        return element.map(proxyWrapper);
      }
      if (typeof element.type === "function") {
        var proxy = getProxyByType(element.type);
        if (proxy) {
          return _extends({}, element, {
            type: proxy.get()
          });
        }
      }
      return element;
    }
    var ERROR_STATE = "react_hot_loader_catched_error";
    var ERROR_STATE_PROTO = "react_hot_loader_catched_error-prototype";
    var OLD_RENDER = "react_hot_loader_original_render";
    function componentDidCatch(error, errorInfo) {
      this[ERROR_STATE] = {
        location: "boundary",
        error,
        errorInfo,
        generation: get$1()
      };
      Object.getPrototypeOf(this)[ERROR_STATE_PROTO] = this[ERROR_STATE];
      if (!configuration.errorReporter) {
        logException(error, errorInfo, this);
      }
      this.forceUpdate();
    }
    function componentRender() {
      var _ref = this[ERROR_STATE] || {}, error = _ref.error, errorInfo = _ref.errorInfo, generation2 = _ref.generation;
      if (error && generation2 === get$1()) {
        return React__default.createElement(configuration.errorReporter || EmptyErrorPlaceholder, {
          error,
          errorInfo,
          component: this
        });
      }
      if (this.hotComponentUpdate) {
        this.hotComponentUpdate();
      }
      try {
        var _OLD_RENDER$render;
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_OLD_RENDER$render = this[OLD_RENDER].render).call.apply(_OLD_RENDER$render, [this].concat(args));
      } catch (renderError) {
        this[ERROR_STATE] = {
          location: "render",
          error: renderError,
          generation: get$1()
        };
        if (!configuration.errorReporter) {
          logException(renderError, void 0, this);
        }
        return componentRender.call(this);
      }
    }
    function retryHotLoaderError() {
      delete this[ERROR_STATE];
      this.forceUpdate();
    }
    setComparisonHooks(function() {
      return {};
    }, function(component) {
      if (!hotComparisonOpen()) {
        return;
      }
      var prototype = component.prototype;
      if (!prototype[OLD_RENDER]) {
        var renderDescriptior = Object.getOwnPropertyDescriptor(prototype, "render");
        prototype[OLD_RENDER] = {
          descriptor: renderDescriptior ? renderDescriptior.value : void 0,
          render: prototype.render
        };
        prototype.componentDidCatch = componentDidCatch;
        prototype.retryHotLoaderError = retryHotLoaderError;
        prototype.render = componentRender;
      }
      delete prototype[ERROR_STATE];
    }, function(_ref2) {
      var prototype = _ref2.prototype;
      if (prototype[OLD_RENDER]) {
        var _ref3 = prototype[ERROR_STATE_PROTO] || {}, generation2 = _ref3.generation;
        if (generation2 === get$1())
          ;
        else {
          delete prototype.componentDidCatch;
          delete prototype.retryHotLoaderError;
          if (prototype.render === componentRender) {
            if (!prototype[OLD_RENDER].descriptor) {
              delete prototype.render;
            } else {
              prototype.render = prototype[OLD_RENDER].descriptor;
            }
          } else {
            console.error("React-Hot-Loader: something unexpectedly mutated Component", prototype);
          }
          delete prototype[ERROR_STATE_PROTO];
          delete prototype[OLD_RENDER];
        }
      }
    });
    setStandInOptions({
      componentWillRender: asyncReconciledRender,
      componentDidRender: proxyWrapper,
      componentDidUpdate: function componentDidUpdate(component) {
        component[RENDERED_GENERATION] = get$1();
        flushScheduledUpdates();
      }
    });
    var AppContainer = function(_React$Component) {
      inherits(AppContainer2, _React$Component);
      AppContainer2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
        if (prevState.generation !== get$1()) {
          return {
            error: null,
            generation: get$1()
          };
        }
        return null;
      };
      function AppContainer2(props) {
        classCallCheck(this, AppContainer2);
        var _this = possibleConstructorReturn(this, _React$Component.call(this, props));
        if (configuration.showReactDomPatchNotification) {
          configuration.showReactDomPatchNotification = false;
          console.warn("React-Hot-Loader: react-\u{1F525}-dom patch is not detected. React 16.6+ features may not work.");
        }
        _this.state = {
          error: null,
          errorInfo: null,
          generation: 0
        };
        return _this;
      }
      AppContainer2.prototype.shouldComponentUpdate = function shouldComponentUpdate(prevProps, prevState) {
        if (prevState.error && this.state.error) {
          return false;
        }
        return true;
      };
      AppContainer2.prototype.componentDidCatch = function componentDidCatch2(error, errorInfo) {
        logger.error(error);
        if (!hotComparisonOpen()) {
          this.setState({});
          throw error;
        }
        var _props$errorReporter = this.props.errorReporter, errorReporter = _props$errorReporter === void 0 ? configuration.errorReporter : _props$errorReporter;
        if (!errorReporter) {
          logException(error, errorInfo, this);
        }
        this.setState({
          error,
          errorInfo
        });
      };
      AppContainer2.prototype.retryHotLoaderError = function retryHotLoaderError$$1() {
        var _this2 = this;
        this.setState({ error: null }, function() {
          retryHotLoaderError.call(_this2);
        });
      };
      AppContainer2.prototype.render = function render2() {
        var _state = this.state, error = _state.error, errorInfo = _state.errorInfo;
        var _props$errorReporter2 = this.props.errorReporter, ErrorReporter = _props$errorReporter2 === void 0 ? configuration.errorReporter || EmptyErrorPlaceholder : _props$errorReporter2;
        if (error && this.props.errorBoundary) {
          return React__default.createElement(ErrorReporter, { error, errorInfo, component: this });
        }
        if (this.hotComponentUpdate) {
          this.hotComponentUpdate();
        } else {
          throw new Error("React-Hot-Loader: AppContainer should be patched");
        }
        return React__default.Children.only(this.props.children);
      };
      return AppContainer2;
    }(React__default.Component);
    AppContainer.reactHotLoadable = false;
    AppContainer.propTypes = {
      children: function children(props) {
        if (React__default.Children.count(props.children) !== 1) {
          return new Error('Invalid prop "children" supplied to AppContainer. Expected a single React element with your app\u2019s root component, e.g. <App />.');
        }
        return void 0;
      },
      errorReporter: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
      errorBoundary: PropTypes.bool
    };
    AppContainer.defaultProps = {
      errorBoundary: true
    };
    var realPolyfill = defaultPolyfill.polyfill || defaultPolyfill__default;
    realPolyfill(AppContainer);
    var lazyConstructor = "_ctor";
    var getLazyConstructor = function getLazyConstructor2(target) {
      if (target[lazyConstructor]) {
        return target[lazyConstructor];
      }
      if (target._payload) {
        return target._payload._result;
      }
      return null;
    };
    var setLazyConstructor = function setLazyConstructor2(target, replacement) {
      replacement.isPatchedByReactHotLoader = true;
      if (target[lazyConstructor]) {
        target[lazyConstructor] = replacement;
      } else if (target._payload) {
        target._payload._hotUpdated = true;
        target._payload._result = replacement;
      } else {
        console.error("could not update lazy component");
      }
    };
    var patched = function patched2(fn) {
      fn.isPatchedByReactHotLoader = true;
      return fn;
    };
    var patchLazyConstructor = function patchLazyConstructor2(target) {
      if (configuration.wrapLazy && !getLazyConstructor(target).isPatchedByReactHotLoader) {
        var ctor = getLazyConstructor(target);
        setLazyConstructor(target, function() {
          return ctor().then(function(m) {
            var C = resolveType(m.default);
            enterHotUpdate();
            if (!React__default.forwardRef) {
              return {
                default: patched(function(props) {
                  return React__default.createElement(
                    AppContainer,
                    null,
                    React__default.createElement(C, props)
                  );
                })
              };
            }
            return {
              default: patched(
                React__default.forwardRef(function HotLoaderLazyWrapper(props, ref) {
                  return React__default.createElement(
                    AppContainer,
                    null,
                    React__default.createElement(C, _extends({}, props, { ref }))
                  );
                })
              )
            };
          });
        });
      }
    };
    var updateLazy = function updateLazy2(target, type) {
      var ctor = getLazyConstructor(type);
      if (getLazyConstructor(target) !== ctor) {
        ctor();
      }
      patchLazyConstructor(target);
      patchLazyConstructor(type);
    };
    var updateMemo = function updateMemo2(target, _ref) {
      var type = _ref.type;
      target.type = resolveType(type);
    };
    var updateForward = function updateForward2(target, _ref2) {
      var render2 = _ref2.render;
      target.render = render2;
    };
    var updateContext = function updateContext2() {
    };
    var getInnerComponentType = function getInnerComponentType2(component) {
      var unwrapper = component[UNWRAP_PROXY];
      return unwrapper ? unwrapper() : component;
    };
    function haveEqualSignatures(prevType, nextType) {
      try {
        var prevSignature = getSignature(prevType);
        var nextSignature = getSignature(nextType);
        if (prevSignature === void 0 && nextSignature === void 0) {
          return true;
        }
        if (prevSignature === void 0 || nextSignature === void 0) {
          return false;
        }
        if (prevSignature.key !== nextSignature.key) {
          return false;
        }
        var prevCustomHooks = prevSignature.getCustomHooks();
        var nextCustomHooks = nextSignature.getCustomHooks();
        if (prevCustomHooks.length !== nextCustomHooks.length) {
          return false;
        }
        for (var i = 0; i < nextCustomHooks.length; i++) {
          if (!haveEqualSignatures(prevCustomHooks[i], nextCustomHooks[i])) {
            return false;
          }
        }
      } catch (e) {
        logger.error("React-Hot-Loader: error occurred while comparing hook signature", e);
        return false;
      }
      return true;
    }
    var areSignaturesCompatible = function areSignaturesCompatible2(a, b) {
      if (!haveEqualSignatures(a, b)) {
        logger.warn("\u269B\uFE0F\u{1F525}\u{1F3A3} Hook order change detected: component", a, "has been remounted");
        return false;
      }
      return true;
    };
    var compareRegistered = function compareRegistered2(a, b) {
      return getIdByType(a) === getIdByType(b) && getProxyByType(a) === getProxyByType(b) && areSignaturesCompatible(a, b);
    };
    var areDeepSwappable = function areDeepSwappable2(oldType, newType) {
      var type = { type: oldType };
      if (typeof oldType === "function") {
        return areSwappable(oldType, newType);
      }
      if (isForwardType(type)) {
        return areDeepSwappable2(oldType.render, newType.render);
      }
      if (isMemoType(type)) {
        return areDeepSwappable2(oldType.type, newType.type);
      }
      return false;
    };
    var compareComponents = function compareComponents2(oldType, newType, setNewType, baseType) {
      var defaultResult = oldType === newType;
      if (oldType && !newType || !oldType && newType || (typeof oldType === "undefined" ? "undefined" : _typeof(oldType)) !== (typeof newType === "undefined" ? "undefined" : _typeof(newType)) || getElementType(oldType) !== getElementType(newType) || 0) {
        return defaultResult;
      }
      if (getIdByType(newType) || getIdByType(oldType)) {
        if (!compareRegistered(oldType, newType)) {
          return false;
        }
        defaultResult = true;
      }
      if (isForwardType({ type: oldType }) && isForwardType({ type: newType })) {
        if (!compareRegistered(oldType.render, newType.render)) {
          return false;
        }
        if (oldType.render === newType.render || areDeepSwappable(oldType, newType)) {
          setNewType(newType);
          return true;
        }
        return defaultResult;
      }
      if (isMemoType({ type: oldType }) && isMemoType({ type: newType })) {
        if (!compareRegistered(oldType.type, newType.type)) {
          return false;
        }
        if (oldType.type === newType.type || areDeepSwappable(oldType, newType)) {
          if (baseType) {
            if (baseType.$$typeof === newType.$$typeof) {
              setNewType(newType);
            } else {
              setNewType(newType.type);
            }
          } else {
            logger.warn("Please update hot-loader/react-dom");
            if (isReactClass(newType.type)) {
              setNewType(newType);
            } else {
              setNewType(newType.type);
            }
          }
          return true;
        }
        return defaultResult;
      }
      if (isLazyType({ type: oldType })) {
        updateLazy(oldType, newType);
        return defaultResult;
      }
      if (isContextType({ type: oldType })) {
        setNewType(newType);
        return defaultResult;
      }
      if (typeof newType === "function" && (defaultResult || newType !== oldType && areSignaturesCompatible(newType, oldType) && areSwappable(newType, oldType))) {
        var unwrapFactory = newType[UNWRAP_PROXY];
        var oldProxy = unwrapFactory && getProxyByType(unwrapFactory());
        if (oldProxy) {
          oldProxy.dereference();
          updateProxyById(oldType[PROXY_KEY] || getIdByType(oldType), getInnerComponentType(newType));
        } else {
          setNewType(newType);
        }
        return true;
      }
      return defaultResult;
    };
    var knownPairs = /* @__PURE__ */ new WeakMap();
    var emptyMap$1 = /* @__PURE__ */ new WeakMap();
    var getKnownPair = function getKnownPair2(oldType, newType) {
      var pair = knownPairs.get(oldType) || emptyMap$1;
      return pair.get(newType);
    };
    var hotComponentCompare = function hotComponentCompare2(oldType, preNewType, setNewType, baseType) {
      var hotActive = hotComparisonOpen();
      var newType = configuration.integratedResolver ? resolveType(preNewType) : preNewType;
      var result = oldType === newType;
      if (hotActive) {
        if (!isReloadableComponent(oldType) || !isReloadableComponent(newType) || isColdType(oldType) || isColdType(oldType) || !oldType || !newType || 0) {
          return result;
        }
        result = compareComponents(oldType, newType, setNewType, baseType);
        var pair = knownPairs.get(oldType) || /* @__PURE__ */ new WeakMap();
        pair.set(newType, result);
        knownPairs.set(oldType, pair);
        return result;
      }
      return result || getKnownPair(oldType, newType) || false;
    };
    var forceSimpleSFC = { proxy: { pureSFC: true } };
    var hookWrapper = function hookWrapper2(hook) {
      var wrappedHook = function wrappedHook2(cb, deps) {
        if (configuration.reloadHooks && deps) {
          var inputs = [].concat(deps);
          if (configuration.reloadHooksOnBodyChange) {
            inputs.push(String(cb));
          }
          if (deps.length > 0 || configuration.reloadLifeCycleHooks && deps.length === 0) {
            inputs.push(getHotGeneration());
          }
          return hook(cb, inputs);
        }
        return hook(cb, deps);
      };
      wrappedHook.isPatchedByReactHotLoader = true;
      return wrappedHook;
    };
    var noDeps = function noDeps2() {
      return [];
    };
    var reactHotLoader = {
      signature: function signature(type, key) {
        var getCustomHooks = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : noDeps;
        addSignature(type, { key, getCustomHooks });
        return type;
      },
      register: function register(type, uniqueLocalName, fileName) {
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        var id = fileName + "#" + uniqueLocalName;
        if (isCompositeComponent(type) && typeof uniqueLocalName === "string" && uniqueLocalName && typeof fileName === "string" && fileName) {
          var proxy = getProxyById(id);
          if (proxy && proxy.getCurrent() !== type) {
            if (!configuration.IS_REACT_MERGE_ENABLED) {
              if (isTypeBlacklisted(type) || isTypeBlacklisted(proxy.getCurrent())) {
                logger.error("React-hot-loader: Cold component", uniqueLocalName, "at", fileName, "has been updated");
              }
            }
          }
          if (configuration.onComponentRegister) {
            configuration.onComponentRegister(type, uniqueLocalName, fileName);
          }
          if (configuration.onComponentCreate) {
            configuration.onComponentCreate(type, getComponentDisplayName(type));
          }
          registerComponent(updateProxyById(id, type, options).get(), 2);
          registerComponent(type);
          increment();
        }
        if (isContextType({ type })) {
          ["Provider", "Consumer"].forEach(function(prop) {
            var descriptor = Object.getOwnPropertyDescriptor(type, prop);
            if (descriptor && descriptor.value) {
              updateFunctionProxyById(id + ":" + prop, descriptor.value, updateContext);
            }
          });
          updateFunctionProxyById(id, type, updateContext);
          increment();
        }
        if (isLazyType({ type })) {
          updateFunctionProxyById(id, type, updateLazy);
          increment();
        }
        if (isForwardType({ type })) {
          reactHotLoader.register(type.render, uniqueLocalName + ":render", fileName, forceSimpleSFC);
          updateFunctionProxyById(id, type, updateForward);
          increment();
        }
        if (isMemoType({ type })) {
          reactHotLoader.register(type.type, uniqueLocalName + ":memo", fileName, forceSimpleSFC);
          updateFunctionProxyById(id, type, updateMemo);
          increment();
        }
      },
      reset: function reset() {
        resetProxies();
      },
      preact: function preact(instance) {
        preactAdapter(instance, resolveType);
      },
      resolveType: function resolveType$$1(type) {
        return resolveType(type);
      },
      patch: function patch(React$$1, ReactDOM$$1) {
        var typeResolver = resolveType;
        if (ReactDOM$$1 && !ReactDOM$$1.render) {
          logger.error("React-Hot-Loader: broken state detected, please import React-Hot-Loader before react-dom, see https://github.com/gaearon/react-hot-loader/issues/1315");
        }
        if (ReactDOM$$1 && ReactDOM$$1.setHotElementComparator) {
          ReactDOM$$1.setHotElementComparator(hotComponentCompare);
          configuration.disableHotRenderer = configuration.disableHotRendererWhenInjected;
          configuration.ignoreSFC = configuration.ignoreSFCWhenInjected;
          configuration.IS_REACT_MERGE_ENABLED = true;
          configuration.showReactDomPatchNotification = false;
          configuration.integratedComparator = true;
          if (ReactDOM$$1.setHotTypeResolver) {
            configuration.integratedResolver = true;
            typeResolver = resolveSimpleType;
            ReactDOM$$1.setHotTypeResolver(resolveType);
          }
        }
        if (!React$$1.createElement.isPatchedByReactHotLoader) {
          var originalCreateElement = React$$1.createElement;
          React$$1.createElement = function(type) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return originalCreateElement.apply(void 0, [typeResolver(type)].concat(args));
          };
          React$$1.createElement.isPatchedByReactHotLoader = true;
        }
        if (!React$$1.cloneElement.isPatchedByReactHotLoader) {
          var originalCloneElement = React$$1.cloneElement;
          React$$1.cloneElement = function(element) {
            for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            var newType = element.type && typeResolver(element.type);
            if (newType && newType !== element.type) {
              return originalCloneElement.apply(void 0, [_extends({}, element, {
                type: newType
              })].concat(args));
            }
            return originalCloneElement.apply(void 0, [element].concat(args));
          };
          React$$1.cloneElement.isPatchedByReactHotLoader = true;
        }
        if (!React$$1.createFactory.isPatchedByReactHotLoader) {
          React$$1.createFactory = function(type) {
            var factory = React$$1.createElement.bind(null, type);
            factory.type = type;
            return factory;
          };
          React$$1.createFactory.isPatchedByReactHotLoader = true;
        }
        if (!React$$1.Children.only.isPatchedByReactHotLoader) {
          var originalChildrenOnly = React$$1.Children.only;
          React$$1.Children.only = function(children) {
            return originalChildrenOnly(_extends({}, children, {
              type: typeResolver(children.type)
            }));
          };
          React$$1.Children.only.isPatchedByReactHotLoader = true;
        }
        if (React$$1.useEffect && !React$$1.useEffect.isPatchedByReactHotLoader) {
          React$$1.useEffect = hookWrapper(React$$1.useEffect);
          React$$1.useLayoutEffect = hookWrapper(React$$1.useLayoutEffect);
          React$$1.useCallback = hookWrapper(React$$1.useCallback);
          React$$1.useMemo = hookWrapper(React$$1.useMemo);
          var useContext = React$$1.useContext;
          React$$1.useContext = function(context) {
            for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }
            return useContext.apply(void 0, [typeResolver(context)].concat(args));
          };
        }
      }
    };
    var openedModules = {};
    var lastModuleOpened = "";
    var getLastModuleOpened = function getLastModuleOpened2() {
      return lastModuleOpened;
    };
    var hotModules = {};
    var createHotModule = function createHotModule2() {
      return { instances: [], updateTimeout: 0 };
    };
    var hotModule = function hotModule2(moduleId) {
      if (!hotModules[moduleId]) {
        hotModules[moduleId] = createHotModule();
      }
      return hotModules[moduleId];
    };
    var isOpened = function isOpened2(sourceModule) {
      return sourceModule && !!openedModules[sourceModule.id];
    };
    var enter = function enter2(sourceModule) {
      if (sourceModule && sourceModule.id) {
        lastModuleOpened = sourceModule.id;
        openedModules[sourceModule.id] = true;
      } else {
        logger.warn("React-hot-loader: no `module` variable found. Did you shadow a system variable?");
      }
    };
    var leave = function leave2(sourceModule) {
      if (sourceModule && sourceModule.id) {
        delete openedModules[sourceModule.id];
      }
    };
    var createQueue = function createQueue2() {
      var runner = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(a) {
        return a();
      };
      var promise = void 0;
      var queue = [];
      var runAll = function runAll2() {
        var oldQueue = queue;
        oldQueue.forEach(function(cb) {
          return cb();
        });
        queue = [];
      };
      var add = function add2(cb) {
        if (queue.length === 0) {
          promise = Promise.resolve().then(function() {
            return runner(runAll);
          });
        }
        queue.push(cb);
        return promise;
      };
      return add;
    };
    var requireIndirect = typeof __webpack_require__ !== "undefined" ? __webpack_require__ : __require;
    var chargeFailbackTimer = function chargeFailbackTimer2(id) {
      return setTimeout(function() {
        var error = 'hot update failed for module "' + id + '". Last file processed: "' + getLastModuleOpened() + '".';
        logger.error(error);
        logException({
          toString: function toString() {
            return error;
          }
        });
      }, 100);
    };
    var clearFailbackTimer = function clearFailbackTimer2(timerId) {
      return clearTimeout(timerId);
    };
    var createHoc = function createHoc2(SourceComponent, TargetComponent) {
      hoistNonReactStatic(TargetComponent, SourceComponent);
      TargetComponent.displayName = "HotExported" + getComponentDisplayName(SourceComponent);
      return TargetComponent;
    };
    var runInRequireQueue = createQueue();
    var runInRenderQueue = createQueue(function(cb) {
      if (ReactDOM.unstable_batchedUpdates) {
        ReactDOM.unstable_batchedUpdates(cb);
      } else {
        cb();
      }
    });
    var makeHotExport = function makeHotExport2(sourceModule, moduleId) {
      var updateInstances = function updateInstances2(possibleError) {
        if (possibleError && possibleError instanceof Error) {
          console.error(possibleError);
          return;
        }
        var module2 = hotModule(moduleId);
        var deepUpdate = function deepUpdate2() {
          runInRenderQueue(function() {
            enterHotUpdate();
            var gen = getHotGeneration();
            module2.instances.forEach(function(inst) {
              return inst.forceUpdate();
            });
            if (configuration.trackTailUpdates) {
              var runLimit = 0;
              var checkTailUpdates = function checkTailUpdates2() {
                setTimeout(function() {
                  if (getHotGeneration() !== gen) {
                    logger.warn("React-Hot-Loader: some components were updated out-of-bound. Updating your app to reconcile the changes.");
                    increment();
                    deepUpdate2();
                  } else if (++runLimit < 5) {
                    checkTailUpdates2();
                  }
                }, 16);
              };
              checkTailUpdates();
            }
          });
        };
        runInRequireQueue(function() {
          try {
            requireIndirect(moduleId);
          } catch (e) {
            console.error("React-Hot-Loader: error detected while loading", moduleId);
            console.error(e);
          }
        }).then(deepUpdate);
      };
      if (sourceModule.hot) {
        sourceModule.hot.accept(updateInstances);
        if (sourceModule.hot.addStatusHandler) {
          if (sourceModule.hot.status() === "idle") {
            sourceModule.hot.addStatusHandler(function(status) {
              if (status === "apply") {
                clearExceptions();
                updateInstances();
              }
            });
          }
        }
      } else {
        logger.warn("React-hot-loader: Hot Module Replacement is not enabled");
      }
    };
    var hot = function hot2(sourceModule) {
      if (!sourceModule) {
        throw new Error("React-hot-loader: `hot` was called without any argument provided");
      }
      var moduleId = sourceModule.id || sourceModule.i || sourceModule.filename;
      if (!moduleId) {
        console.error("`module` provided", sourceModule);
        throw new Error("React-hot-loader: `hot` could not find the `name` of the the `module` you have provided");
      }
      var module2 = hotModule(moduleId);
      makeHotExport(sourceModule, moduleId);
      clearExceptions();
      var failbackTimer = chargeFailbackTimer(moduleId);
      var firstHotRegistered = false;
      return function(WrappedComponent, props) {
        clearFailbackTimer(failbackTimer);
        if (!firstHotRegistered) {
          firstHotRegistered = true;
          reactHotLoader.register(WrappedComponent, getComponentDisplayName(WrappedComponent), "RHL" + moduleId);
        }
        return createHoc(WrappedComponent, function(_Component) {
          inherits(ExportedComponent, _Component);
          function ExportedComponent() {
            classCallCheck(this, ExportedComponent);
            return possibleConstructorReturn(this, _Component.apply(this, arguments));
          }
          ExportedComponent.prototype.componentDidMount = function componentDidMount() {
            module2.instances.push(this);
          };
          ExportedComponent.prototype.componentWillUnmount = function componentWillUnmount() {
            var _this2 = this;
            if (isOpened(sourceModule)) {
              var componentName = getComponentDisplayName(WrappedComponent);
              logger.error("React-hot-loader: Detected AppContainer unmount on module '" + moduleId + "' update.\n" + ('Did you use "hot(' + componentName + ')" and "ReactDOM.render()" in the same file?\n') + ('"hot(' + componentName + ')" shall only be used as export.\n') + 'Please refer to "Getting Started" (https://github.com/gaearon/react-hot-loader/).');
            }
            module2.instances = module2.instances.filter(function(a) {
              return a !== _this2;
            });
          };
          ExportedComponent.prototype.render = function render2() {
            return React__default.createElement(
              AppContainer,
              props,
              React__default.createElement(WrappedComponent, this.props)
            );
          };
          return ExportedComponent;
        }(React.Component));
      };
    };
    reactHotLoader.register(AppContainer, "AppContainer", "hot-dev");
    var getProxyOrType = function getProxyOrType2(type) {
      var proxy = getProxyByType(type);
      return proxy ? proxy.get() : type;
    };
    var areComponentsEqual = function areComponentsEqual2(a, b) {
      return getProxyOrType(a) === getProxyOrType(b);
    };
    var compareOrSwap = function compareOrSwap2(oldType, newType) {
      return hotComponentCompare(oldType, newType);
    };
    var cold = function cold2(type) {
      blacklistByType(type);
      return type;
    };
    var configureComponent = function configureComponent2(component, options) {
      return setComponentOptions(component, options);
    };
    var setConfig = function setConfig2(config) {
      return setConfiguration(config);
    };
    reactHotLoader.patch(React__default, ReactDOM);
    exports.default = reactHotLoader;
    exports.AppContainer = AppContainer;
    exports.hot = hot;
    exports.enterModule = enter;
    exports.leaveModule = leave;
    exports.areComponentsEqual = areComponentsEqual;
    exports.compareOrSwap = compareOrSwap;
    exports.cold = cold;
    exports.configureComponent = configureComponent;
    exports.setConfig = setConfig;
  }
});

export {
  require_react_hot_loader_production_min,
  require_react_hot_loader_development
};
//# sourceMappingURL=chunk-G5RC4F3C.js.map
